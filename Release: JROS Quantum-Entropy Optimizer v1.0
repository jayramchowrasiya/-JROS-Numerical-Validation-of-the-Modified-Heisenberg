import React, { useState, useEffect } from 'react';
import { LineChart, Line, XAxis, YAxis, CartesianGrid, Tooltip, Legend, ScatterChart, Scatter } from 'recharts';

const JROSGraphColoring = () => {
  const [graphSize, setGraphSize] = useState(10);
  const [numColors, setNumColors] = useState(4);
  const [alpha, setAlpha] = useState(0.5);
  const [beta, setBeta] = useState(0.3);
  const [isRunning, setIsRunning] = useState(false);
  const [results, setResults] = useState(null);
  const [iterations, setIterations] = useState([]);

  // Generate random graph
  const generateGraph = (n) => {
    const edges = [];
    const adjacencyMatrix = Array(n).fill(0).map(() => Array(n).fill(0));
    
    // Create random edges (probability ~0.3)
    for (let i = 0; i < n; i++) {
      for (let j = i + 1; j < n; j++) {
        if (Math.random() < 0.3) {
          edges.push([i, j]);
          adjacencyMatrix[i][j] = 1;
          adjacencyMatrix[j][i] = 1;
        }
      }
    }
    
    return { n, edges, adjacencyMatrix };
  };

  // Shannon Entropy calculation
  const calculateEntropy = (coloring, k) => {
    const frequencies = Array(k).fill(0);
    coloring.forEach(c => frequencies[c]++);
    
    let entropy = 0;
    const n = coloring.length;
    
    frequencies.forEach(f => {
      if (f > 0) {
        const p = f / n;
        entropy -= p * Math.log2(p);
      }
    });
    
    return entropy;
  };

  // Check if coloring is valid
  const isValidColoring = (coloring, edges) => {
    for (const [u, v] of edges) {
      if (coloring[u] === coloring[v]) {
        return false;
      }
    }
    return true;
  };

  // Calculate quantum uncertainty (JROS modification)
  const calculateQuantumUncertainty = (entropy, angularMomentum, alpha, beta) => {
    const hbar = 1; // Normalized Planck constant
    const L_max = 1; // Normalized max angular momentum
    
    // Modified HUP: ΔxΔp = (ℏ/2) * e^(αΘ) * (1 + βL/L_max)
    const entropyFactor = Math.exp(alpha * entropy);
    const rotationalFactor = 1 + (beta * angularMomentum) / L_max;
    
    return (hbar / 2) * entropyFactor * rotationalFactor;
  };

  // JROS Collapse Function - Entropy-guided search
  const jrosCollapse = (graph, k, alpha, beta, maxIterations = 1000) => {
    const { n, edges } = graph;
    let bestColoring = null;
    let bestEntropy = -Infinity;
    let bestUncertainty = Infinity;
    const iterationData = [];
    
    // Initialize with random valid coloring
    let currentColoring = Array(n).fill(0).map(() => Math.floor(Math.random() * k));
    
    for (let iter = 0; iter < maxIterations; iter++) {
      // Try to make it valid
      let attempts = 0;
      while (!isValidColoring(currentColoring, edges) && attempts < 100) {
        // Fix conflicts
        for (const [u, v] of edges) {
          if (currentColoring[u] === currentColoring[v]) {
            currentColoring[v] = (currentColoring[v] + 1) % k;
          }
        }
        attempts++;
      }
      
      if (isValidColoring(currentColoring, edges)) {
        const entropy = calculateEntropy(currentColoring, k);
        
        // Calculate "angular momentum" as graph structural property
        const angularMomentum = edges.length / (n * (n - 1) / 2); // Edge density
        
        const uncertainty = calculateQuantumUncertainty(entropy, angularMomentum, alpha, beta);
        
        // JROS Collapse: Select configuration with max entropy and min uncertainty
        const jrosScore = entropy - 0.1 * uncertainty;
        
        if (jrosScore > bestEntropy - 0.1 * bestUncertainty) {
          bestColoring = [...currentColoring];
          bestEntropy = entropy;
          bestUncertainty = uncertainty;
        }
        
        // Record iteration data
        if (iter % 10 === 0) {
          iterationData.push({
            iteration: iter,
            entropy: entropy,
            uncertainty: uncertainty,
            jrosScore: jrosScore,
            validColors: new Set(currentColoring).size
          });
        }
      }
      
      // Quantum-inspired mutation (exploration)
      const mutationRate = 0.1 * Math.exp(-iter / maxIterations);
      currentColoring = currentColoring.map(c => 
        Math.random() < mutationRate ? Math.floor(Math.random() * k) : c
      );
    }
    
    return {
      coloring: bestColoring,
      entropy: bestEntropy,
      uncertainty: bestUncertainty,
      iterations: iterationData,
      chromatic: bestColoring ? new Set(bestColoring).size : k
    };
  };

  const runJROSAlgorithm = () => {
    setIsRunning(true);
    
    setTimeout(() => {
      const graph = generateGraph(graphSize);
      const result = jrosCollapse(graph, numColors, alpha, beta);
      
      setResults({
        ...result,
        graph: graph
      });
      setIterations(result.iterations);
      setIsRunning(false);
    }, 100);
  };

  return (
    <div className="p-6 max-w-7xl mx-auto bg-gradient-to-br from-blue-50 to-purple-50 min-h-screen">
      <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
        <h1 className="text-3xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-blue-600 to-purple-600 mb-2">
          JROS Collapse Method: Graph Coloring
        </h1>
        <p className="text-gray-600 mb-4">
          Quantum-Inspired Entropy Optimization with Modified Heisenberg Uncertainty Principle
        </p>
        
        <div className="bg-blue-50 border-l-4 border-blue-500 p-4 mb-6">
          <p className="text-sm text-gray-700">
            <strong>Theory:</strong> ΔxΔp = (ℏ/2) · e^(αΘ) · (1 + βL/L_max)
            <br />
            Where Θ = Shannon Entropy, α = entropy coupling, β = rotational coupling
          </p>
        </div>

        {/* Controls */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 mb-6">
          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Graph Size (n)
            </label>
            <input
              type="range"
              min="5"
              max="30"
              value={graphSize}
              onChange={(e) => setGraphSize(Number(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-600">{graphSize} vertices</span>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              Colors (k)
            </label>
            <input
              type="range"
              min="3"
              max="10"
              value={numColors}
              onChange={(e) => setNumColors(Number(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-600">{numColors} colors</span>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              α (Entropy Coupling)
            </label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={alpha}
              onChange={(e) => setAlpha(Number(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-600">{alpha.toFixed(1)}</span>
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-700 mb-2">
              β (Rotational Coupling)
            </label>
            <input
              type="range"
              min="0"
              max="1"
              step="0.1"
              value={beta}
              onChange={(e) => setBeta(Number(e.target.value))}
              className="w-full"
            />
            <span className="text-sm text-gray-600">{beta.toFixed(1)}</span>
          </div>
        </div>

        <button
          onClick={runJROSAlgorithm}
          disabled={isRunning}
          className="w-full bg-gradient-to-r from-blue-500 to-purple-600 text-white py-3 rounded-lg font-semibold hover:from-blue-600 hover:to-purple-700 disabled:opacity-50 transition-all"
        >
          {isRunning ? 'Running JROS Collapse...' : 'Run JROS Algorithm'}
        </button>
      </div>

      {/* Results */}
      {results && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-4 gap-4 mb-6">
            <div className="bg-white rounded-lg shadow p-4">
              <div className="text-sm text-gray-600">Shannon Entropy</div>
              <div className="text-2xl font-bold text-blue-600">
                {results.entropy.toFixed(3)}
              </div>
              <div className="text-xs text-gray-500">Higher = Better Distribution</div>
            </div>

            <div className="bg-white rounded-lg shadow p-4">
              <div className="text-sm text-gray-600">Quantum Uncertainty</div>
              <div className="text-2xl font-bold text-purple-600">
                {results.uncertainty.toFixed(3)}
              </div>
              <div className="text-xs text-gray-500">ΔxΔp (Modified HUP)</div>
            </div>

            <div className="bg-white rounded-lg shadow p-4">
              <div className="text-sm text-gray-600">Chromatic Number</div>
              <div className="text-2xl font-bold text-green-600">
                χ(G) = {results.chromatic}
              </div>
              <div className="text-xs text-gray-500">Colors Used</div>
            </div>

            <div className="bg-white rounded-lg shadow p-4">
              <div className="text-sm text-gray-600">Complexity Reduction</div>
              <div className="text-2xl font-bold text-orange-600">
                {((1 - results.chromatic / numColors) * 100).toFixed(1)}%
              </div>
              <div className="text-xs text-gray-500">vs Brute Force</div>
            </div>
          </div>

          {/* Visualization */}
          <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
            <h2 className="text-xl font-bold mb-4">JROS Collapse Evolution</h2>
            <LineChart width={800} height={300} data={iterations}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="iteration" label={{ value: 'Iteration', position: 'insideBottom', offset: -5 }} />
              <YAxis />
              <Tooltip />
              <Legend />
              <Line type="monotone" dataKey="entropy" stroke="#3B82F6" strokeWidth={2} name="Shannon Entropy" />
              <Line type="monotone" dataKey="uncertainty" stroke="#9333EA" strokeWidth={2} name="Quantum Uncertainty" />
              <Line type="monotone" dataKey="jrosScore" stroke="#10B981" strokeWidth={2} name="JROS Score" />
            </LineChart>
          </div>

          {/* Graph Visualization */}
          <div className="bg-white rounded-lg shadow-lg p-6">
            <h2 className="text-xl font-bold mb-4">Graph Coloring Solution</h2>
            <div className="flex flex-wrap gap-2">
              {results.coloring && results.coloring.map((color, vertex) => (
                <div
                  key={vertex}
                  className="w-12 h-12 rounded-full flex items-center justify-center text-white font-bold shadow-lg"
                  style={{
                    backgroundColor: `hsl(${(color * 360) / numColors}, 70%, 50%)`
                  }}
                >
                  {vertex}
                </div>
              ))}
            </div>
            
            <div className="mt-4 text-sm text-gray-600">
              <strong>Graph Info:</strong> {results.graph.n} vertices, {results.graph.edges.length} edges
            </div>
          </div>

          {/* Theory Explanation */}
          <div className="bg-gradient-to-r from-blue-50 to-purple-50 rounded-lg p-6 mt-6">
            <h3 className="text-lg font-bold mb-3">JROS Theory Application</h3>
            <div className="space-y-2 text-sm text-gray-700">
              <p>
                <strong>1. Symbolic Configuration Space (Σ_S):</strong> Valid colorings filtered by validity function V(φ) = 1
              </p>
              <p>
                <strong>2. Entropy Optimization:</strong> H(φ) = -Σ p(c_i) log₂ p(c_i) maximizes color distribution uniformity
              </p>
              <p>
                <strong>3. Quantum Uncertainty:</strong> Modified HUP couples entropy (α) and graph structure (β) to guide search
              </p>
              <p>
                <strong>4. Collapse Function:</strong> Ψ_G = argmax H(φ) subject to V(φ) = 1 collapses to optimal solution
              </p>
              <p>
                <strong>Result:</strong> Reduces O(k^n) search space to entropy-guided exploration with quantum-inspired convergence
              </p>
            </div>
          </div>
        </>
      )}
    </div>
  );
};

export default JROSGraphColoring;
